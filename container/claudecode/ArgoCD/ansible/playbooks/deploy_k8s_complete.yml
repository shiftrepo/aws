---
# ========================================
# å®Œå…¨Kubernetesç’°å¢ƒæ§‹ç¯‰ - 0ã‹ã‚‰ã®è‡ªå‹•åŒ–
# ========================================
# K3s + ArgoCD + ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã‚’è‡ªå‹•æ§‹ç¯‰
#
# å®Ÿè¡Œæ–¹æ³•:
#   cd /root/aws.git/container/claudecode/ArgoCD/ansible
#   ansible-playbook playbooks/deploy_k8s_complete.yml
# ========================================

- name: Deploy Complete Kubernetes Environment from Scratch
  hosts: localhost
  become: yes
  gather_facts: yes

  vars:
    # ansible/config/environment.yml ã‹ã‚‰å–å¾—
    project_root: "{{ environment_config.directories.base_dir }}"
    backend_dir: "{{ project_root }}/app/backend"
    frontend_dir: "{{ project_root }}/app/frontend"
    k8s_manifests_dir: "{{ project_root }}/k8s-manifests"
    private_ip: "{{ ansible_default_ipv4.address }}"
    app_version: "{{ environment_config.application.version }}"

  pre_tasks:
    - name: Load environment configuration
      include_vars:
        file: "{{ playbook_dir }}/../config/environment.yml"
        name: environment_config

      tags: [always]
    - name: Detect container runtime (docker first, fallback to environment.yml)
      block:
        - name: Check docker availability
          command: docker info
          register: docker_check
          failed_when: false
          changed_when: false
          become: no

        - name: Set container runtime to docker
          set_fact:
            container_cmd: "docker"
          when: docker_check.rc == 0

        - name: Set container runtime from environment.yml (fallback)
          set_fact:
            container_cmd: "{{ environment_config.containers.runtime }}"
          when: docker_check.rc != 0

        - name: Display container runtime
          debug:
            msg: "Using container runtime: {{ container_cmd }}"
      tags: [always]

    - name: Detect ansible-playbook executable path
      block:
        - name: Find ansible-playbook binary
          shell: which ansible-playbook 2>/dev/null || find /usr/local/bin /usr/bin -name ansible-playbook 2>/dev/null | head -1
          register: ap_path
          changed_when: false
          failed_when: ap_path.stdout == ""

        - name: Set ansible_playbook_cmd fact
          set_fact:
            ansible_playbook_cmd: "{{ ap_path.stdout }}"

        - name: Display ansible-playbook path
          debug:
            msg: "Using ansible-playbook: {{ ansible_playbook_cmd }}"
      tags: [always]

  tasks:
    # ========================================
    # Phase 0: ç’°å¢ƒç¢ºèª
    # ========================================
    - name: Display deployment information
      debug:
        msg:
          - "=========================================="
          - "Kubernetes Complete Deployment"
          - "=========================================="
          - "Project Root: {{ project_root }}"
          - "Private IP: {{ private_ip }}"
          - "=========================================="

    # ========================================
    # Phase 1: K3sã¨ArgoCDã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    # ========================================
    - name: "PHASE 1: Install K3s and ArgoCD"
      block:
        - name: Check if K3s is already installed
          stat:
            path: /usr/local/bin/k3s
          register: k3s_bin

        - name: Install K3s and ArgoCD
          command: "{{ ansible_playbook_cmd }} {{ project_root }}/ansible/playbooks/install_k3s_and_argocd.yml"
          args:
            chdir: "{{ project_root }}/ansible"
          when: not k3s_bin.stat.exists
          register: k3s_install
          changed_when: true

        - name: Wait for K3s to be ready
          command: /usr/local/bin/k3s kubectl get nodes
          register: k3s_nodes
          until: "'Ready' in k3s_nodes.stdout"
          retries: 60
          delay: 10
          changed_when: false
          failed_when: false

        - name: Wait for ArgoCD pods to be ready
          shell: /usr/local/bin/k3s kubectl get pods -n argocd --no-headers 2>/dev/null | grep -v Running | wc -l
          register: argocd_status
          until: argocd_status.stdout | trim == "0"
          retries: 90
          delay: 10
          changed_when: false
          failed_when: false

        - name: Display K3s and ArgoCD status
          debug:
            msg:
              - "âœ… K3s cluster is ready"
              - "âœ… ArgoCD is running"

      tags:
        - k3s
        - argocd

    # ========================================
    # Phase 2: ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    # ========================================
    - name: "PHASE 2: Install Build Tools"
      block:
        - name: Check if Maven is installed
          command: bash -lc "mvn --version"
          register: maven_check
          failed_when: false
          changed_when: false

        - name: Install build tools if not present
          command: "{{ ansible_playbook_cmd }} {{ project_root }}/ansible/playbooks/install_build_tools.yml"
          args:
            chdir: "{{ project_root }}/ansible"
          when: maven_check.rc != 0
          register: build_tools_install
          changed_when: true

        - name: Verify Maven installation
          shell: bash -lc "source /etc/profile.d/maven.sh && mvn --version"
          register: maven_verify
          changed_when: false

        - name: Display build tools status
          debug:
            msg: "âœ… Build tools are ready"

      tags:
        - build-tools

    # ========================================
    # Phase 3: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ“ãƒ«ãƒ‰
    # ========================================
    - name: "PHASE 3: Build Applications"
      block:
        - name: Build backend with Maven
          shell: |
            source /etc/profile.d/maven.sh
            cd {{ backend_dir }}
            mvn clean package -DskipTests -Dmaven.test.skip=true
          args:
            executable: /bin/bash
          register: backend_build
          changed_when: true

        - name: Verify backend JAR exists
          stat:
            path: "{{ backend_dir }}/target/orgmgmt-backend.jar"
          register: backend_jar
          failed_when: not backend_jar.stat.exists

        - name: Install frontend dependencies
          command: npm install
          args:
            chdir: "{{ frontend_dir }}"
          register: npm_install
          changed_when: true

        - name: Build frontend with Vite
          command: npm run build
          args:
            chdir: "{{ frontend_dir }}"
          register: frontend_build
          changed_when: true

        - name: Verify frontend dist exists
          stat:
            path: "{{ frontend_dir }}/dist"
          register: frontend_dist
          failed_when: not frontend_dist.stat.exists

        - name: Display build status
          debug:
            msg:
              - "âœ… Backend JAR built successfully"
              - "âœ… Frontend dist built successfully"

      tags:
        - build

    # ========================================
    # Phase 4: ã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ“ãƒ«ãƒ‰
    # ========================================
    - name: "PHASE 4: Build Container Images"
      block:
        - name: Pull base images
          command: "{{ container_cmd }} pull docker.io/library/eclipse-temurin:21-jre-alpine"
          register: pull_base
          changed_when: true

        - name: Build backend container image
          command: "{{ container_cmd }} build -t orgmgmt-backend:{{ app_version }} -t orgmgmt-backend:latest -f Dockerfile ."
          args:
            chdir: "{{ backend_dir }}"
          register: backend_image
          changed_when: true

        - name: Build frontend container image
          command: "{{ container_cmd }} build -t orgmgmt-frontend:{{ app_version }} -t orgmgmt-frontend:latest -f Dockerfile ."
          args:
            chdir: "{{ frontend_dir }}"
          register: frontend_image
          changed_when: true

        - name: Remove old export files
          file:
            path: "{{ item }}"
            state: absent
          loop:
            - /tmp/backend.tar
            - /tmp/frontend.tar
          become: yes

        - name: Export backend image
          command: "{{ container_cmd }} save localhost/orgmgmt-backend:{{ app_version }} localhost/orgmgmt-backend:latest -o /tmp/backend.tar"
          register: export_backend
          changed_when: true

        - name: Export frontend image
          command: "{{ container_cmd }} save localhost/orgmgmt-frontend:{{ app_version }} localhost/orgmgmt-frontend:latest -o /tmp/frontend.tar"
          register: export_frontend
          changed_when: true

        - name: Import images into K3s
          shell: |
            /usr/local/bin/k3s ctr images import /tmp/backend.tar
            /usr/local/bin/k3s ctr images import /tmp/frontend.tar
          register: import_images
          changed_when: true

        - name: Verify images in K3s
          command: /usr/local/bin/k3s crictl images
          register: k3s_images
          changed_when: false

        - name: Display image build status
          debug:
            msg:
              - "âœ… Backend image built and imported"
              - "âœ… Frontend image built and imported"

      tags:
        - images

    # ========================================
    # Phase 5: Kubernetesã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤
    # ========================================
    - name: "PHASE 5: Deploy to Kubernetes"
      block:
        - name: Deploy PostgreSQL
          command: /usr/local/bin/k3s kubectl apply -f {{ k8s_manifests_dir }}/postgres-deployment.yaml
          register: deploy_postgres
          changed_when: true

        - name: Deploy Redis
          command: /usr/local/bin/k3s kubectl apply -f {{ k8s_manifests_dir }}/redis-deployment.yaml
          register: deploy_redis
          changed_when: true

        - name: Wait for PostgreSQL to be ready
          shell: /usr/local/bin/k3s kubectl get pods -l app=postgres --no-headers | grep Running | wc -l
          register: postgres_status
          until: postgres_status.stdout == "1"
          retries: 30
          delay: 10
          changed_when: false

        - name: Wait for Redis to be ready
          shell: /usr/local/bin/k3s kubectl get pods -l app=redis --no-headers | grep Running | wc -l
          register: redis_status
          until: redis_status.stdout == "1"
          retries: 30
          delay: 10
          changed_when: false

        - name: Deploy Backend
          shell: |
            /usr/local/bin/k3s kubectl apply -f {{ k8s_manifests_dir }}/backend-deployment.yaml
            /usr/local/bin/k3s kubectl apply -f {{ k8s_manifests_dir }}/backend-service.yaml
          register: deploy_backend
          changed_when: true

        - name: Deploy Frontend
          shell: |
            /usr/local/bin/k3s kubectl apply -f {{ k8s_manifests_dir }}/frontend-deployment.yaml
            /usr/local/bin/k3s kubectl apply -f {{ k8s_manifests_dir }}/frontend-service.yaml
          register: deploy_frontend
          changed_when: true

        - name: Wait for Backend pods to be ready
          shell: /usr/local/bin/k3s kubectl get pods -l app=orgmgmt-backend --no-headers | grep Running | wc -l
          register: backend_status
          until: backend_status.stdout == "2"
          retries: 60
          delay: 10
          changed_when: false

        - name: Wait for Frontend pods to be ready
          shell: /usr/local/bin/k3s kubectl get pods -l app=orgmgmt-frontend --no-headers | grep Running | wc -l
          register: frontend_status
          until: frontend_status.stdout == "2"
          retries: 60
          delay: 10
          changed_when: false

        - name: Display deployment status
          debug:
            msg:
              - "âœ… PostgreSQL deployed and ready"
              - "âœ… Redis deployed and ready"
              - "âœ… Backend deployed and ready (2 replicas)"
              - "âœ… Frontend deployed and ready (2 replicas)"

      tags:
        - deploy

    # ========================================
    # Phase 5.5: ç’°å¢ƒä¾å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹•çš„æ›´æ–°
    # ========================================
    - name: "PHASE 5.5: Update Environment-Specific Parameters"
      block:
        - name: Update backend service external IP
          command: >
            /usr/local/bin/k3s kubectl patch service orgmgmt-backend
            -n default
            -p '{"spec":{"externalIPs":["{{ private_ip }}"]}}'
          register: patch_backend_service
          changed_when: true

        - name: Update frontend service external IP
          command: >
            /usr/local/bin/k3s kubectl patch service orgmgmt-frontend
            -n default
            -p '{"spec":{"externalIPs":["{{ private_ip }}"]}}'
          register: patch_frontend_service
          changed_when: true

        - name: Update backend deployment image tag
          command: >
            /usr/local/bin/k3s kubectl set image
            deployment/orgmgmt-backend
            backend=localhost/orgmgmt-backend:{{ app_version }}
            -n default
          register: update_backend_image
          changed_when: true

        - name: Update frontend deployment image tag
          command: >
            /usr/local/bin/k3s kubectl set image
            deployment/orgmgmt-frontend
            frontend=localhost/orgmgmt-frontend:{{ app_version }}
            -n default
          register: update_frontend_image
          changed_when: true

        - name: Wait for backend rollout to complete
          command: /usr/local/bin/k3s kubectl rollout status deployment/orgmgmt-backend -n default --timeout=180s
          register: backend_rollout
          changed_when: false

        - name: Wait for frontend rollout to complete
          command: /usr/local/bin/k3s kubectl rollout status deployment/orgmgmt-frontend -n default --timeout=180s
          register: frontend_rollout
          changed_when: false

        - name: Display parameter update status
          debug:
            msg:
              - "âœ… Backend service external IP updated to: {{ private_ip }}"
              - "âœ… Frontend service external IP updated to: {{ private_ip }}"
              - "âœ… Backend image updated to: localhost/orgmgmt-backend:{{ app_version }}"
              - "âœ… Frontend image updated to: localhost/orgmgmt-frontend:{{ app_version }}"
              - "âœ… All environment-specific parameters are now dynamic!"

      tags:
        - parameterize

    # ========================================
    # Phase 6: ã‚µãƒ¼ãƒ“ã‚¹ç¢ºèª
    # ========================================
    - name: "PHASE 6: Verify Services"
      block:
        - name: Get all pods status
          command: /usr/local/bin/k3s kubectl get pods -o wide
          register: all_pods
          changed_when: false

        - name: Get all services
          command: /usr/local/bin/k3s kubectl get svc
          register: all_services
          changed_when: false

        - name: Get backend service details
          shell: /usr/local/bin/k3s kubectl get svc orgmgmt-backend -o jsonpath='{.spec.ports[0].port}'
          register: backend_port
          changed_when: false

        - name: Get frontend service details
          shell: /usr/local/bin/k3s kubectl get svc orgmgmt-frontend -o jsonpath='{.spec.ports[0].port}'
          register: frontend_port
          changed_when: false

        - name: Wait for backend health check
          uri:
            url: "http://{{ private_ip }}:{{ backend_port.stdout }}/actuator/health"
            status_code: 200
          register: backend_health
          until: backend_health.status == 200
          retries: 30
          delay: 10

        - name: Wait for frontend to respond
          uri:
            url: "http://{{ private_ip }}:{{ frontend_port.stdout }}/"
            status_code: 200
          register: frontend_health
          until: frontend_health.status == 200
          retries: 30
          delay: 10

        - name: Display final status
          debug:
            msg:
              - "=========================================="
              - "DEPLOYMENT COMPLETE!"
              - "=========================================="
              - ""
              - "ArgoCD:"
              - "  URL: https://{{ private_ip }}:30010"
              - "  Credentials: /root/argocd-credentials.txt"
              - ""
              - "Backend:"
              - "  API: http://{{ private_ip }}:{{ backend_port.stdout }}"
              - "  Health: http://{{ private_ip }}:{{ backend_port.stdout }}/actuator/health"
              - ""
              - "Frontend:"
              - "  URL: http://{{ private_ip }}:{{ frontend_port.stdout }}"
              - ""
              - "Pods Status:"
              - "{{ all_pods.stdout_lines }}"
              - ""
              - "Services:"
              - "{{ all_services.stdout_lines }}"
              - ""
              - "=========================================="

      tags:
        - verify


    # ========================================
    # Phase 7: ãƒãƒ¼ãƒˆè»¢é€è¨­å®š (socat)
    # ========================================
    - name: "PHASE 7: Setup Port Forwarding with socat"
      block:
        - name: Install socat
          package:
            name: socat
            state: present

        - name: Get NodePorts
          shell: |
            FRONTEND=$(/usr/local/bin/k3s kubectl get svc orgmgmt-frontend -n default -o jsonpath='{.spec.ports[0].nodePort}')
            BACKEND=$(/usr/local/bin/k3s kubectl get svc orgmgmt-backend -n default -o jsonpath='{.spec.ports[0].nodePort}')
            ARGOCD_HTTP=$(/usr/local/bin/k3s kubectl get svc argocd-server -n argocd -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}')
            ARGOCD_HTTPS=$(/usr/local/bin/k3s kubectl get svc argocd-server -n argocd -o jsonpath='{.spec.ports[?(@.name=="https")].nodePort}')
            echo "FRONTEND=$FRONTEND BACKEND=$BACKEND ARGOCD_HTTP=$ARGOCD_HTTP ARGOCD_HTTPS=$ARGOCD_HTTPS"
          register: nodeports_output
          changed_when: false

        - name: Parse NodePorts
          set_fact:
            frontend_nodeport: "{{ (nodeports_output.stdout | regex_search('FRONTEND=(\\d+)', '\\1') | default(['0'])) | first }}"
            backend_nodeport: "{{ (nodeports_output.stdout | regex_search('BACKEND=(\\d+)', '\\1') | default(['0'])) | first }}"
            argocd_http_nodeport: "{{ (nodeports_output.stdout | regex_search('ARGOCD_HTTP=(\\d+)', '\\1') | default(['0'])) | first }}"
            argocd_https_nodeport: "{{ (nodeports_output.stdout | regex_search('ARGOCD_HTTPS=(\\d+)', '\\1') | default(['0'])) | first }}"

        - name: Create socat systemd service for Frontend
          copy:
            content: |
              [Unit]
              Description=Socat Port Forward - Frontend (5006 -> {{ frontend_nodeport }})
              After=network.target k3s.service
              Requires=k3s.service

              [Service]
              Type=simple
              User=root
              ExecStart=/usr/bin/socat TCP-LISTEN:5006,bind=0.0.0.0,fork,reuseaddr TCP:127.0.0.1:{{ frontend_nodeport }}
              Restart=always
              RestartSec=5
              StandardOutput=journal
              StandardError=journal

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/socat-frontend.service
            mode: '0644'

        - name: Create socat systemd service for Backend
          copy:
            content: |
              [Unit]
              Description=Socat Port Forward - Backend (8083 -> {{ backend_nodeport }})
              After=network.target k3s.service
              Requires=k3s.service

              [Service]
              Type=simple
              User=root
              ExecStart=/usr/bin/socat TCP-LISTEN:8083,bind=0.0.0.0,fork,reuseaddr TCP:127.0.0.1:{{ backend_nodeport }}
              Restart=always
              RestartSec=5
              StandardOutput=journal
              StandardError=journal

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/socat-backend.service
            mode: '0644'

        - name: Create socat systemd service for ArgoCD HTTP
          copy:
            content: |
              [Unit]
              Description=Socat Port Forward - ArgoCD HTTP (8000 -> {{ argocd_http_nodeport }})
              After=network.target k3s.service
              Requires=k3s.service

              [Service]
              Type=simple
              User=root
              ExecStart=/usr/bin/socat TCP-LISTEN:8000,bind=0.0.0.0,fork,reuseaddr TCP:127.0.0.1:{{ argocd_http_nodeport }}
              Restart=always
              RestartSec=5
              StandardOutput=journal
              StandardError=journal

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/socat-argocd-http.service
            mode: '0644'

        - name: Create socat systemd service for ArgoCD HTTPS
          copy:
            content: |
              [Unit]
              Description=Socat Port Forward - ArgoCD HTTPS (8082 -> {{ argocd_https_nodeport }})
              After=network.target k3s.service
              Requires=k3s.service

              [Service]
              Type=simple
              User=root
              ExecStart=/usr/bin/socat TCP-LISTEN:8082,bind=0.0.0.0,fork,reuseaddr TCP:127.0.0.1:{{ argocd_https_nodeport }}
              Restart=always
              RestartSec=5
              StandardOutput=journal
              StandardError=journal

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/socat-argocd-https.service
            mode: '0644'

        - name: Reload systemd daemon
          command: systemctl daemon-reload
          changed_when: true

        - name: Enable and start socat services
          systemd:
            name: "{{ item }}"
            enabled: yes
            state: started
            daemon_reload: yes
          loop:
            - socat-frontend
            - socat-backend
            - socat-argocd-http
            - socat-argocd-https

        - name: Add iptables rules for external access ports (insert at beginning)
          shell: |
            iptables -D INPUT -p tcp --dport {{ item }} -j ACCEPT 2>/dev/null || true
            iptables -I INPUT 1 -p tcp --dport {{ item }} -j ACCEPT
          become: yes
          loop:
            - 5006
            - 8083
            - 8000
            - 8082

        - name: Save iptables rules
          shell: iptables-save > /etc/sysconfig/iptables
          become: yes
          failed_when: false

        - name: Verify socat services
          shell: ss -tlnp | grep -E "5006|8083|8082|8000" || true
          register: listening_ports
          changed_when: false

        - name: Display port forwarding status
          debug:
            msg:
              - "âœ… Socat port forwarding configured"
              - "Listening ports:"
              - "{{ listening_ports.stdout_lines }}"
              - ""
              - "Port mappings:"
              - "  5006 (Frontend) -> {{ frontend_nodeport }}"
              - "  8083 (Backend) -> {{ backend_nodeport }}"
              - "  8000 (ArgoCD HTTP) -> {{ argocd_http_nodeport }}"
              - "  8082 (ArgoCD HTTPS) -> {{ argocd_https_nodeport }}"

      tags:
        - port-forwarding
        - socat

    # ========================================
    # Phase 8: ArgoCD GitOpsè¨­å®š
    # ========================================
    - name: "PHASE 8: Configure ArgoCD GitOps Application"
      block:
        - name: Check if ArgoCD Application already exists
          shell: /usr/local/bin/k3s kubectl get application orgmgmt-app -n argocd
          register: argocd_app_check
          changed_when: false
          failed_when: false

        - name: Apply ArgoCD Application manifest
          shell: /usr/local/bin/k3s kubectl apply -f {{ project_root }}/argocd-application.yaml
          when: argocd_app_check.rc != 0
          register: argocd_app_apply

        - name: Wait for ArgoCD Application to sync
          shell: |
            /usr/local/bin/k3s kubectl wait --for=condition=Synced application/orgmgmt-app -n argocd --timeout=300s || true
          register: argocd_sync_wait
          changed_when: false

        - name: Get ArgoCD Application status
          shell: /usr/local/bin/k3s kubectl get application orgmgmt-app -n argocd -o jsonpath='{.status.sync.status}:{.status.health.status}'
          register: argocd_app_status
          changed_when: false

        - name: Display ArgoCD GitOps status
          debug:
            msg:
              - "âœ… ArgoCD GitOps configured"
              - "Application: orgmgmt-app"
              - "Repository: https://github.com/shiftrepo/aws.git"
              - "Path: container/claudecode/ArgoCD/k8s-manifests"
              - "Branch: main"
              - "Status: {{ argocd_app_status.stdout }}"
              - ""
              - "GitOps Features:"
              - "  - Automated Sync: Enabled (every 3 minutes)"
              - "  - Self Heal: Enabled"
              - "  - Prune: Enabled"

      tags:
        - argocd-gitops

    # ========================================
    # Phase 9: Kubernetes Dashboard Setup
    # ========================================
    - name: "PHASE 9: Install and Configure Kubernetes Dashboard"
      block:
        - name: Check if Dashboard is already installed
          shell: /usr/local/bin/k3s kubectl get namespace kubernetes-dashboard
          register: dashboard_ns_check
          changed_when: false
          failed_when: false

        - name: Install Kubernetes Dashboard
          shell: |
            /usr/local/bin/k3s kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
          when: dashboard_ns_check.rc != 0

        - name: Wait for Dashboard pods to be ready
          shell: |
            /usr/local/bin/k3s kubectl wait --for=condition=ready pod \
              -l k8s-app=kubernetes-dashboard \
              -n kubernetes-dashboard \
              --timeout=300s
          when: dashboard_ns_check.rc != 0

        - name: Create Dashboard admin ServiceAccount
          shell: |
            /usr/local/bin/k3s kubectl apply -f - <<EOF
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: admin-user
              namespace: kubernetes-dashboard
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: admin-user
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: cluster-admin
            subjects:
            - kind: ServiceAccount
              name: admin-user
              namespace: kubernetes-dashboard
            EOF
          when: dashboard_ns_check.rc != 0

        - name: Patch Dashboard Service to NodePort
          shell: |
            /usr/local/bin/k3s kubectl patch svc kubernetes-dashboard -n kubernetes-dashboard \
              -p '{"spec": {"type": "NodePort", "ports": [{"port": 443, "targetPort": 8443, "nodePort": 30000}]}}'
          when: dashboard_ns_check.rc != 0

        - name: Generate Dashboard access token
          shell: |
            /usr/local/bin/k3s kubectl create token admin-user \
              -n kubernetes-dashboard \
              --duration=87600h
          register: dashboard_token
          changed_when: false

        - name: Save Dashboard token to file
          copy:
            content: "{{ dashboard_token.stdout }}"
            dest: /root/k8s-dashboard-token.txt
            mode: '0600'

        - name: Create socat service for Dashboard
          copy:
            content: |
              [Unit]
              Description=Socat Port Forward - Kubernetes Dashboard (3000 -> 30000)
              After=network.target k3s.service
              Requires=k3s.service

              [Service]
              Type=simple
              User=root
              ExecStart=/usr/bin/socat TCP-LISTEN:3000,bind=0.0.0.0,fork,reuseaddr TCP:127.0.0.1:30000
              Restart=always
              RestartSec=5
              StandardOutput=journal
              StandardError=journal

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/socat-k8s-dashboard.service
            mode: '0644'

        - name: Enable and start Dashboard socat service
          systemd:
            name: socat-k8s-dashboard
            enabled: yes
            state: started
            daemon_reload: yes

        - name: Add iptables rule for port 3000 (insert at beginning)
          shell: |
            iptables -D INPUT -p tcp --dport 3000 -j ACCEPT 2>/dev/null || true
            iptables -I INPUT 1 -p tcp --dport 3000 -j ACCEPT
          become: yes

        - name: Save iptables rules
          shell: iptables-save > /etc/sysconfig/iptables
          become: yes
          failed_when: false

        - name: Display Kubernetes Dashboard status
          debug:
            msg:
              - "âœ… Kubernetes Dashboard installed"
              - "Access URL: https://{{ private_ip }}:3000"
              - "Token saved to: /root/k8s-dashboard-token.txt"
              - "Token (first 50 chars): {{ dashboard_token.stdout[:50] }}..."

      tags:
        - k8s-dashboard

    # ========================================
    # Final Status Summary
    # ========================================
    - name: Display deployment completion summary
      debug:
        msg:
          - "=========================================="
          - "ðŸŽ‰ DEPLOYMENT COMPLETE!"
          - "=========================================="
          - ""
          - "âœ… K3s Cluster: Running"
          - "âœ… ArgoCD: Running"
          - "âœ… Applications: Deployed"
          - "âœ… GitOps: Configured"
          - "âœ… External Access: Configured"
          - ""
          - "Access URLs:"
          - "  Frontend:     http://{{ private_ip }}:5006"
          - "  Backend API:  http://{{ private_ip }}:8083"
          - "  ArgoCD HTTPS: https://{{ private_ip }}:8082"
          - "  ArgoCD HTTP:  http://{{ private_ip }}:8000"
          - "  K8s Dashboard: https://{{ private_ip }}:3000"
          - ""
          - "Credentials:"
          - "  ArgoCD: /root/argocd-credentials.txt"
          - "  K8s Dashboard Token: /root/k8s-dashboard-token.txt"
          - ""
          - "=========================================="

    # ========================================
    # Display Authentication Credentials
    # ========================================
    - name: Get ArgoCD admin password
      shell: |
        /usr/local/bin/k3s kubectl get secret argocd-initial-admin-secret \
          -n argocd \
          -o jsonpath="{.data.password}" | base64 -d
      register: argocd_admin_password
      changed_when: false
      no_log: false

    - name: Display authentication credentials
      debug:
        msg:
          - ""
          - "=========================================="
          - "ðŸ”‘ AUTHENTICATION CREDENTIALS"
          - "=========================================="
          - ""
          - "ArgoCD Admin Credentials:"
          - "  Username: admin"
          - "  Password: {{ argocd_admin_password.stdout }}"
          - ""
          - "Kubernetes Dashboard Token:"
          - "  {{ dashboard_token.stdout }}"
          - ""
          - "Credentials Files:"
          - "  ArgoCD: /root/argocd-credentials.txt"
          - "  K8s Dashboard: /root/k8s-dashboard-token.txt"
          - ""
          - "=========================================="
