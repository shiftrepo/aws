#!/usr/bin/env python3
"""
Natural Language Query Processor for patentDWH with direct Bedrock SQL generation fallback

This module extends the base NLQueryProcessor with a direct Bedrock API call
for SQL generation when the primary SQL generation method fails.
"""

import os
import json
import logging
import boto3
from typing import Dict, List, Any, Optional
import httpx

# Import base NLQueryProcessor
from base_nl_query_processor import NLQueryProcessor as BaseNLQueryProcessor
from base_nl_query_processor import get_base_nl_processor

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s'
)
logger = logging.getLogger(__name__)

# AWS Bedrock settings
CLAUDE_MODEL_ID = "anthropic.claude-3-haiku-20240307-v1:0"

# Patent DB API URL from environment variable
PATENT_DB_URL = os.environ.get("PATENT_DB_URL", "http://patentdwh-db:5002")

class NLQueryProcessor(BaseNLQueryProcessor):
    """
    Extended Natural Language Query Processor for patentDWH
    
    Adds direct Bedrock API SQL generation as a fallback when SQL queries 
    aren't properly generated by the primary method.
    """

    def __init__(self):
        """Initialize the NL query processor."""
        super().__init__()  # Initialize parent class
        
    async def _generate_fallback_sql(self, query: str, db_type: str) -> str:
        """
        Generate SQL using direct Bedrock API call as a fallback method.
        
        Args:
            query: Natural language query
            db_type: Database type
            
        Returns:
            Generated SQL query
        """
        try:
            if not self.is_aws_configured or not self.bedrock_runtime:
                logger.error("Bedrock client not available")
                return ""
            
            # Get schema information for this database type with retry logic
            schema_info = self.schemas.get(db_type, {})
            if not schema_info or "tables" not in schema_info or not schema_info["tables"]:
                logger.warning("Schema information is missing or incomplete, attempting to refresh schemas")
                # Try to refresh schemas
                self.schemas = self._get_database_schemas()
                schema_info = self.schemas.get(db_type, {})
            
            # Format schema information for the prompt
            schema_text = "テーブル一覧:\n"
            for table_name, table_info in schema_info.get("tables", {}).items():
                columns = table_info.get("columns", [])
                if not columns:
                    continue
                
                schema_text += f"\nテーブル: {table_name}\n"
                schema_text += "カラム:\n"
                for col in columns:
                    schema_text += f"- {col}\n"
            
            # Create a prompt for SQL generation
            prompt = f"""あなたは特許データベースのSQLクエリ生成の専門家です。
次のSQL問い合わせを生成してください。

### データベースの種類: SQLite

### データベーススキーマ情報:
{schema_text}

### 質問:
{query}

### 応答:
SQLクエリのみを出力してください。説明は不要です。バックティック(```)やSQL識別子も含めないでください。
"""

            # Call Bedrock
            response = self.bedrock_runtime.invoke_model(
                modelId=CLAUDE_MODEL_ID,
                body=json.dumps({
                    "anthropic_version": "bedrock-2023-05-31",
                    "max_tokens": 1000,
                    "temperature": 0,
                    "system": "あなたは特許データベースのSQLクエリ生成専門AIアシスタントです。ユーザーの質問に対して必ずSQLクエリのみを返します。",
                    "messages": [{"role": "user", "content": prompt}]
                })
            )
            
            # Parse response
            response_body = json.loads(response.get("body").read())
            sql_query = response_body.get("content", [{}])[0].get("text", "")
            
            # Clean up the SQL query
            if "```sql" in sql_query:
                sql_query = sql_query.split("```sql")[1].split("```")[0].strip()
            elif "```" in sql_query:
                sql_query = sql_query.split("```")[1].split("```")[0].strip()
            
            logger.info(f"Fallback generated SQL: {sql_query}")
            return sql_query
            
        except Exception as e:
            logger.error(f"Error generating fallback SQL: {e}")
            return ""
    
    async def process_query(self, query: str, db_type: str = "inpit") -> Dict:
        """
        Process a natural language query about patents with Bedrock fallback.
        
        Args:
            query: Natural language query string
            db_type: Database to query against
            
        Returns:
            Dict containing query results and generated response
        """
        try:
            # Check if AWS is configured
            if not self.is_aws_configured:
                return {
                    "success": False,
                    # Note: AWS_REGIONは使わず、AWS_DEFAULT_REGIONを利用すること。
                    "error": "AWS Bedrock設定エラー: AWS認証情報が設定されていないか無効です。AWS_ACCESS_KEY_ID、AWS_SECRET_ACCESS_KEY、AWS_DEFAULT_REGIONが適切に設定されていることを確認してください。"
                }
            
            # First try the original SQL generation method
            sql_query = await self._generate_sql(query, db_type)
            used_fallback = False
            
            # If original method didn't generate SQL or it's invalid, try direct Bedrock fallback
            if not sql_query or not sql_query.strip().upper().startswith(("SELECT", "WITH")):
                logger.info(f"Original SQL generation failed or produced invalid SQL. Using fallback method.")
                fallback_sql = await self._generate_fallback_sql(query, db_type)
                
                if fallback_sql and (fallback_sql.strip().upper().startswith(("SELECT", "WITH"))):
                    sql_query = fallback_sql
                    used_fallback = True
                    logger.info(f"Using fallback generated SQL: {sql_query}")
                else:
                    logger.error("Both SQL generation methods failed")
                    return {
                        "success": False,
                        "error": "SQLクエリの生成に失敗しました。別のクエリを試してください。"
                    }
            
            # Execute the SQL query against the database
            response = httpx.post(
                f"{PATENT_DB_URL}/api/sql-query",
                json={"query": sql_query, "db_type": db_type}
            )
            
            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"SQL実行エラー: {response.text}"
                }
                
            sql_result = response.json()
            
            # Generate natural language response from the SQL results
            nl_response = await self._generate_response(query, sql_result, db_type)
            
            # Return the combined result
            return {
                "success": True,
                "query": query,
                "sql": sql_query,
                "db_type": db_type,
                "sql_result": sql_result,
                "response": nl_response,
                "used_fallback": used_fallback
            }
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return {
                "success": False,
                "error": f"クエリ処理エラー: {str(e)}"
            }

# Singleton instance for reuse
_instance = None

def get_nl_processor():
    """Get a singleton instance of the NLQueryProcessor."""
    global _instance
    if _instance is None:
        _instance = NLQueryProcessor()
    return _instance
